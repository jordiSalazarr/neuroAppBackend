// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// LettersCancellationSubtest is an object representing the database table.
type LettersCancellationSubtest struct {
	ID                string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	EvaluationID      string      `boil:"evaluation_id" json:"evaluation_id" toml:"evaluation_id" yaml:"evaluation_id"`
	TotalTargets      int         `boil:"total_targets" json:"total_targets" toml:"total_targets" yaml:"total_targets"`
	Correct           int         `boil:"correct" json:"correct" toml:"correct" yaml:"correct"`
	Errors            int         `boil:"errors" json:"errors" toml:"errors" yaml:"errors"`
	TimeInSecs        int         `boil:"time_in_secs" json:"time_in_secs" toml:"time_in_secs" yaml:"time_in_secs"`
	AssistantAnalysis null.String `boil:"assistant_analysis" json:"assistant_analysis,omitempty" toml:"assistant_analysis" yaml:"assistant_analysis,omitempty"`
	Score             int         `boil:"score" json:"score" toml:"score" yaml:"score"`
	CPPerMin          float64     `boil:"cp_per_min" json:"cp_per_min" toml:"cp_per_min" yaml:"cp_per_min"`
	Accuracy          float64     `boil:"accuracy" json:"accuracy" toml:"accuracy" yaml:"accuracy"`
	Omissions         int         `boil:"omissions" json:"omissions" toml:"omissions" yaml:"omissions"`
	OmissionsRate     float64     `boil:"omissions_rate" json:"omissions_rate" toml:"omissions_rate" yaml:"omissions_rate"`
	CommissionRate    float64     `boil:"commission_rate" json:"commission_rate" toml:"commission_rate" yaml:"commission_rate"`
	HitsPerMin        float64     `boil:"hits_per_min" json:"hits_per_min" toml:"hits_per_min" yaml:"hits_per_min"`
	ErrorsPerMin      float64     `boil:"errors_per_min" json:"errors_per_min" toml:"errors_per_min" yaml:"errors_per_min"`
	CreatedAt         time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *lettersCancellationSubtestR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L lettersCancellationSubtestL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var LettersCancellationSubtestColumns = struct {
	ID                string
	EvaluationID      string
	TotalTargets      string
	Correct           string
	Errors            string
	TimeInSecs        string
	AssistantAnalysis string
	Score             string
	CPPerMin          string
	Accuracy          string
	Omissions         string
	OmissionsRate     string
	CommissionRate    string
	HitsPerMin        string
	ErrorsPerMin      string
	CreatedAt         string
}{
	ID:                "id",
	EvaluationID:      "evaluation_id",
	TotalTargets:      "total_targets",
	Correct:           "correct",
	Errors:            "errors",
	TimeInSecs:        "time_in_secs",
	AssistantAnalysis: "assistant_analysis",
	Score:             "score",
	CPPerMin:          "cp_per_min",
	Accuracy:          "accuracy",
	Omissions:         "omissions",
	OmissionsRate:     "omissions_rate",
	CommissionRate:    "commission_rate",
	HitsPerMin:        "hits_per_min",
	ErrorsPerMin:      "errors_per_min",
	CreatedAt:         "created_at",
}

var LettersCancellationSubtestTableColumns = struct {
	ID                string
	EvaluationID      string
	TotalTargets      string
	Correct           string
	Errors            string
	TimeInSecs        string
	AssistantAnalysis string
	Score             string
	CPPerMin          string
	Accuracy          string
	Omissions         string
	OmissionsRate     string
	CommissionRate    string
	HitsPerMin        string
	ErrorsPerMin      string
	CreatedAt         string
}{
	ID:                "letters_cancellation_subtests.id",
	EvaluationID:      "letters_cancellation_subtests.evaluation_id",
	TotalTargets:      "letters_cancellation_subtests.total_targets",
	Correct:           "letters_cancellation_subtests.correct",
	Errors:            "letters_cancellation_subtests.errors",
	TimeInSecs:        "letters_cancellation_subtests.time_in_secs",
	AssistantAnalysis: "letters_cancellation_subtests.assistant_analysis",
	Score:             "letters_cancellation_subtests.score",
	CPPerMin:          "letters_cancellation_subtests.cp_per_min",
	Accuracy:          "letters_cancellation_subtests.accuracy",
	Omissions:         "letters_cancellation_subtests.omissions",
	OmissionsRate:     "letters_cancellation_subtests.omissions_rate",
	CommissionRate:    "letters_cancellation_subtests.commission_rate",
	HitsPerMin:        "letters_cancellation_subtests.hits_per_min",
	ErrorsPerMin:      "letters_cancellation_subtests.errors_per_min",
	CreatedAt:         "letters_cancellation_subtests.created_at",
}

// Generated where

var LettersCancellationSubtestWhere = struct {
	ID                whereHelperstring
	EvaluationID      whereHelperstring
	TotalTargets      whereHelperint
	Correct           whereHelperint
	Errors            whereHelperint
	TimeInSecs        whereHelperint
	AssistantAnalysis whereHelpernull_String
	Score             whereHelperint
	CPPerMin          whereHelperfloat64
	Accuracy          whereHelperfloat64
	Omissions         whereHelperint
	OmissionsRate     whereHelperfloat64
	CommissionRate    whereHelperfloat64
	HitsPerMin        whereHelperfloat64
	ErrorsPerMin      whereHelperfloat64
	CreatedAt         whereHelpertime_Time
}{
	ID:                whereHelperstring{field: "`letters_cancellation_subtests`.`id`"},
	EvaluationID:      whereHelperstring{field: "`letters_cancellation_subtests`.`evaluation_id`"},
	TotalTargets:      whereHelperint{field: "`letters_cancellation_subtests`.`total_targets`"},
	Correct:           whereHelperint{field: "`letters_cancellation_subtests`.`correct`"},
	Errors:            whereHelperint{field: "`letters_cancellation_subtests`.`errors`"},
	TimeInSecs:        whereHelperint{field: "`letters_cancellation_subtests`.`time_in_secs`"},
	AssistantAnalysis: whereHelpernull_String{field: "`letters_cancellation_subtests`.`assistant_analysis`"},
	Score:             whereHelperint{field: "`letters_cancellation_subtests`.`score`"},
	CPPerMin:          whereHelperfloat64{field: "`letters_cancellation_subtests`.`cp_per_min`"},
	Accuracy:          whereHelperfloat64{field: "`letters_cancellation_subtests`.`accuracy`"},
	Omissions:         whereHelperint{field: "`letters_cancellation_subtests`.`omissions`"},
	OmissionsRate:     whereHelperfloat64{field: "`letters_cancellation_subtests`.`omissions_rate`"},
	CommissionRate:    whereHelperfloat64{field: "`letters_cancellation_subtests`.`commission_rate`"},
	HitsPerMin:        whereHelperfloat64{field: "`letters_cancellation_subtests`.`hits_per_min`"},
	ErrorsPerMin:      whereHelperfloat64{field: "`letters_cancellation_subtests`.`errors_per_min`"},
	CreatedAt:         whereHelpertime_Time{field: "`letters_cancellation_subtests`.`created_at`"},
}

// LettersCancellationSubtestRels is where relationship names are stored.
var LettersCancellationSubtestRels = struct {
	Evaluation string
}{
	Evaluation: "Evaluation",
}

// lettersCancellationSubtestR is where relationships are stored.
type lettersCancellationSubtestR struct {
	Evaluation *Evaluation `boil:"Evaluation" json:"Evaluation" toml:"Evaluation" yaml:"Evaluation"`
}

// NewStruct creates a new relationship struct
func (*lettersCancellationSubtestR) NewStruct() *lettersCancellationSubtestR {
	return &lettersCancellationSubtestR{}
}

func (o *LettersCancellationSubtest) GetEvaluation() *Evaluation {
	if o == nil {
		return nil
	}

	return o.R.GetEvaluation()
}

func (r *lettersCancellationSubtestR) GetEvaluation() *Evaluation {
	if r == nil {
		return nil
	}

	return r.Evaluation
}

// lettersCancellationSubtestL is where Load methods for each relationship are stored.
type lettersCancellationSubtestL struct{}

var (
	lettersCancellationSubtestAllColumns            = []string{"id", "evaluation_id", "total_targets", "correct", "errors", "time_in_secs", "assistant_analysis", "score", "cp_per_min", "accuracy", "omissions", "omissions_rate", "commission_rate", "hits_per_min", "errors_per_min", "created_at"}
	lettersCancellationSubtestColumnsWithoutDefault = []string{"id", "evaluation_id", "total_targets", "correct", "errors", "time_in_secs", "assistant_analysis", "score", "cp_per_min", "accuracy", "omissions", "omissions_rate", "commission_rate", "hits_per_min", "errors_per_min"}
	lettersCancellationSubtestColumnsWithDefault    = []string{"created_at"}
	lettersCancellationSubtestPrimaryKeyColumns     = []string{"id"}
	lettersCancellationSubtestGeneratedColumns      = []string{}
)

type (
	// LettersCancellationSubtestSlice is an alias for a slice of pointers to LettersCancellationSubtest.
	// This should almost always be used instead of []LettersCancellationSubtest.
	LettersCancellationSubtestSlice []*LettersCancellationSubtest
	// LettersCancellationSubtestHook is the signature for custom LettersCancellationSubtest hook methods
	LettersCancellationSubtestHook func(context.Context, boil.ContextExecutor, *LettersCancellationSubtest) error

	lettersCancellationSubtestQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	lettersCancellationSubtestType                 = reflect.TypeOf(&LettersCancellationSubtest{})
	lettersCancellationSubtestMapping              = queries.MakeStructMapping(lettersCancellationSubtestType)
	lettersCancellationSubtestPrimaryKeyMapping, _ = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, lettersCancellationSubtestPrimaryKeyColumns)
	lettersCancellationSubtestInsertCacheMut       sync.RWMutex
	lettersCancellationSubtestInsertCache          = make(map[string]insertCache)
	lettersCancellationSubtestUpdateCacheMut       sync.RWMutex
	lettersCancellationSubtestUpdateCache          = make(map[string]updateCache)
	lettersCancellationSubtestUpsertCacheMut       sync.RWMutex
	lettersCancellationSubtestUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var lettersCancellationSubtestAfterSelectMu sync.Mutex
var lettersCancellationSubtestAfterSelectHooks []LettersCancellationSubtestHook

var lettersCancellationSubtestBeforeInsertMu sync.Mutex
var lettersCancellationSubtestBeforeInsertHooks []LettersCancellationSubtestHook
var lettersCancellationSubtestAfterInsertMu sync.Mutex
var lettersCancellationSubtestAfterInsertHooks []LettersCancellationSubtestHook

var lettersCancellationSubtestBeforeUpdateMu sync.Mutex
var lettersCancellationSubtestBeforeUpdateHooks []LettersCancellationSubtestHook
var lettersCancellationSubtestAfterUpdateMu sync.Mutex
var lettersCancellationSubtestAfterUpdateHooks []LettersCancellationSubtestHook

var lettersCancellationSubtestBeforeDeleteMu sync.Mutex
var lettersCancellationSubtestBeforeDeleteHooks []LettersCancellationSubtestHook
var lettersCancellationSubtestAfterDeleteMu sync.Mutex
var lettersCancellationSubtestAfterDeleteHooks []LettersCancellationSubtestHook

var lettersCancellationSubtestBeforeUpsertMu sync.Mutex
var lettersCancellationSubtestBeforeUpsertHooks []LettersCancellationSubtestHook
var lettersCancellationSubtestAfterUpsertMu sync.Mutex
var lettersCancellationSubtestAfterUpsertHooks []LettersCancellationSubtestHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *LettersCancellationSubtest) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *LettersCancellationSubtest) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *LettersCancellationSubtest) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *LettersCancellationSubtest) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *LettersCancellationSubtest) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *LettersCancellationSubtest) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *LettersCancellationSubtest) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *LettersCancellationSubtest) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *LettersCancellationSubtest) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range lettersCancellationSubtestAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddLettersCancellationSubtestHook registers your hook function for all future operations.
func AddLettersCancellationSubtestHook(hookPoint boil.HookPoint, lettersCancellationSubtestHook LettersCancellationSubtestHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		lettersCancellationSubtestAfterSelectMu.Lock()
		lettersCancellationSubtestAfterSelectHooks = append(lettersCancellationSubtestAfterSelectHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		lettersCancellationSubtestBeforeInsertMu.Lock()
		lettersCancellationSubtestBeforeInsertHooks = append(lettersCancellationSubtestBeforeInsertHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		lettersCancellationSubtestAfterInsertMu.Lock()
		lettersCancellationSubtestAfterInsertHooks = append(lettersCancellationSubtestAfterInsertHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		lettersCancellationSubtestBeforeUpdateMu.Lock()
		lettersCancellationSubtestBeforeUpdateHooks = append(lettersCancellationSubtestBeforeUpdateHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		lettersCancellationSubtestAfterUpdateMu.Lock()
		lettersCancellationSubtestAfterUpdateHooks = append(lettersCancellationSubtestAfterUpdateHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		lettersCancellationSubtestBeforeDeleteMu.Lock()
		lettersCancellationSubtestBeforeDeleteHooks = append(lettersCancellationSubtestBeforeDeleteHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		lettersCancellationSubtestAfterDeleteMu.Lock()
		lettersCancellationSubtestAfterDeleteHooks = append(lettersCancellationSubtestAfterDeleteHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		lettersCancellationSubtestBeforeUpsertMu.Lock()
		lettersCancellationSubtestBeforeUpsertHooks = append(lettersCancellationSubtestBeforeUpsertHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		lettersCancellationSubtestAfterUpsertMu.Lock()
		lettersCancellationSubtestAfterUpsertHooks = append(lettersCancellationSubtestAfterUpsertHooks, lettersCancellationSubtestHook)
		lettersCancellationSubtestAfterUpsertMu.Unlock()
	}
}

// One returns a single lettersCancellationSubtest record from the query.
func (q lettersCancellationSubtestQuery) One(ctx context.Context, exec boil.ContextExecutor) (*LettersCancellationSubtest, error) {
	o := &LettersCancellationSubtest{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: failed to execute a one query for letters_cancellation_subtests")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all LettersCancellationSubtest records from the query.
func (q lettersCancellationSubtestQuery) All(ctx context.Context, exec boil.ContextExecutor) (LettersCancellationSubtestSlice, error) {
	var o []*LettersCancellationSubtest

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dbmodels: failed to assign all query results to LettersCancellationSubtest slice")
	}

	if len(lettersCancellationSubtestAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all LettersCancellationSubtest records in the query.
func (q lettersCancellationSubtestQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to count letters_cancellation_subtests rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q lettersCancellationSubtestQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: failed to check if letters_cancellation_subtests exists")
	}

	return count > 0, nil
}

// Evaluation pointed to by the foreign key.
func (o *LettersCancellationSubtest) Evaluation(mods ...qm.QueryMod) evaluationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.EvaluationID),
	}

	queryMods = append(queryMods, mods...)

	return Evaluations(queryMods...)
}

// LoadEvaluation allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (lettersCancellationSubtestL) LoadEvaluation(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLettersCancellationSubtest interface{}, mods queries.Applicator) error {
	var slice []*LettersCancellationSubtest
	var object *LettersCancellationSubtest

	if singular {
		var ok bool
		object, ok = maybeLettersCancellationSubtest.(*LettersCancellationSubtest)
		if !ok {
			object = new(LettersCancellationSubtest)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeLettersCancellationSubtest)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeLettersCancellationSubtest))
			}
		}
	} else {
		s, ok := maybeLettersCancellationSubtest.(*[]*LettersCancellationSubtest)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeLettersCancellationSubtest)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeLettersCancellationSubtest))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &lettersCancellationSubtestR{}
		}
		args[object.EvaluationID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lettersCancellationSubtestR{}
			}

			args[obj.EvaluationID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`evaluations`),
		qm.WhereIn(`evaluations.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Evaluation")
	}

	var resultSlice []*Evaluation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Evaluation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for evaluations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for evaluations")
	}

	if len(evaluationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Evaluation = foreign
		if foreign.R == nil {
			foreign.R = &evaluationR{}
		}
		foreign.R.LettersCancellationSubtests = append(foreign.R.LettersCancellationSubtests, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.EvaluationID == foreign.ID {
				local.R.Evaluation = foreign
				if foreign.R == nil {
					foreign.R = &evaluationR{}
				}
				foreign.R.LettersCancellationSubtests = append(foreign.R.LettersCancellationSubtests, local)
				break
			}
		}
	}

	return nil
}

// SetEvaluation of the lettersCancellationSubtest to the related item.
// Sets o.R.Evaluation to related.
// Adds o to related.R.LettersCancellationSubtests.
func (o *LettersCancellationSubtest) SetEvaluation(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Evaluation) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `letters_cancellation_subtests` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"evaluation_id"}),
		strmangle.WhereClause("`", "`", 0, lettersCancellationSubtestPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.EvaluationID = related.ID
	if o.R == nil {
		o.R = &lettersCancellationSubtestR{
			Evaluation: related,
		}
	} else {
		o.R.Evaluation = related
	}

	if related.R == nil {
		related.R = &evaluationR{
			LettersCancellationSubtests: LettersCancellationSubtestSlice{o},
		}
	} else {
		related.R.LettersCancellationSubtests = append(related.R.LettersCancellationSubtests, o)
	}

	return nil
}

// LettersCancellationSubtests retrieves all the records using an executor.
func LettersCancellationSubtests(mods ...qm.QueryMod) lettersCancellationSubtestQuery {
	mods = append(mods, qm.From("`letters_cancellation_subtests`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`letters_cancellation_subtests`.*"})
	}

	return lettersCancellationSubtestQuery{q}
}

// FindLettersCancellationSubtest retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindLettersCancellationSubtest(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*LettersCancellationSubtest, error) {
	lettersCancellationSubtestObj := &LettersCancellationSubtest{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `letters_cancellation_subtests` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, lettersCancellationSubtestObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dbmodels: unable to select from letters_cancellation_subtests")
	}

	if err = lettersCancellationSubtestObj.doAfterSelectHooks(ctx, exec); err != nil {
		return lettersCancellationSubtestObj, err
	}

	return lettersCancellationSubtestObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *LettersCancellationSubtest) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no letters_cancellation_subtests provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(lettersCancellationSubtestColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	lettersCancellationSubtestInsertCacheMut.RLock()
	cache, cached := lettersCancellationSubtestInsertCache[key]
	lettersCancellationSubtestInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			lettersCancellationSubtestAllColumns,
			lettersCancellationSubtestColumnsWithDefault,
			lettersCancellationSubtestColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `letters_cancellation_subtests` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `letters_cancellation_subtests` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `letters_cancellation_subtests` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, lettersCancellationSubtestPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to insert into letters_cancellation_subtests")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to populate default values for letters_cancellation_subtests")
	}

CacheNoHooks:
	if !cached {
		lettersCancellationSubtestInsertCacheMut.Lock()
		lettersCancellationSubtestInsertCache[key] = cache
		lettersCancellationSubtestInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the LettersCancellationSubtest.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *LettersCancellationSubtest) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	lettersCancellationSubtestUpdateCacheMut.RLock()
	cache, cached := lettersCancellationSubtestUpdateCache[key]
	lettersCancellationSubtestUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			lettersCancellationSubtestAllColumns,
			lettersCancellationSubtestPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dbmodels: unable to update letters_cancellation_subtests, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `letters_cancellation_subtests` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, lettersCancellationSubtestPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, append(wl, lettersCancellationSubtestPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update letters_cancellation_subtests row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by update for letters_cancellation_subtests")
	}

	if !cached {
		lettersCancellationSubtestUpdateCacheMut.Lock()
		lettersCancellationSubtestUpdateCache[key] = cache
		lettersCancellationSubtestUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q lettersCancellationSubtestQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all for letters_cancellation_subtests")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected for letters_cancellation_subtests")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o LettersCancellationSubtestSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), lettersCancellationSubtestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `letters_cancellation_subtests` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, lettersCancellationSubtestPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to update all in lettersCancellationSubtest slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to retrieve rows affected all in update all lettersCancellationSubtest")
	}
	return rowsAff, nil
}

var mySQLLettersCancellationSubtestUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *LettersCancellationSubtest) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("dbmodels: no letters_cancellation_subtests provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(lettersCancellationSubtestColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLLettersCancellationSubtestUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	lettersCancellationSubtestUpsertCacheMut.RLock()
	cache, cached := lettersCancellationSubtestUpsertCache[key]
	lettersCancellationSubtestUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			lettersCancellationSubtestAllColumns,
			lettersCancellationSubtestColumnsWithDefault,
			lettersCancellationSubtestColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			lettersCancellationSubtestAllColumns,
			lettersCancellationSubtestPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("dbmodels: unable to upsert letters_cancellation_subtests, could not build update column list")
		}

		ret := strmangle.SetComplement(lettersCancellationSubtestAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`letters_cancellation_subtests`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `letters_cancellation_subtests` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to upsert for letters_cancellation_subtests")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(lettersCancellationSubtestType, lettersCancellationSubtestMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to retrieve unique values for letters_cancellation_subtests")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to populate default values for letters_cancellation_subtests")
	}

CacheNoHooks:
	if !cached {
		lettersCancellationSubtestUpsertCacheMut.Lock()
		lettersCancellationSubtestUpsertCache[key] = cache
		lettersCancellationSubtestUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single LettersCancellationSubtest record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *LettersCancellationSubtest) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dbmodels: no LettersCancellationSubtest provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), lettersCancellationSubtestPrimaryKeyMapping)
	sql := "DELETE FROM `letters_cancellation_subtests` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete from letters_cancellation_subtests")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by delete for letters_cancellation_subtests")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q lettersCancellationSubtestQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dbmodels: no lettersCancellationSubtestQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from letters_cancellation_subtests")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for letters_cancellation_subtests")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o LettersCancellationSubtestSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(lettersCancellationSubtestBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), lettersCancellationSubtestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `letters_cancellation_subtests` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, lettersCancellationSubtestPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: unable to delete all from lettersCancellationSubtest slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dbmodels: failed to get rows affected by deleteall for letters_cancellation_subtests")
	}

	if len(lettersCancellationSubtestAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *LettersCancellationSubtest) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindLettersCancellationSubtest(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *LettersCancellationSubtestSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := LettersCancellationSubtestSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), lettersCancellationSubtestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `letters_cancellation_subtests`.* FROM `letters_cancellation_subtests` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, lettersCancellationSubtestPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dbmodels: unable to reload all in LettersCancellationSubtestSlice")
	}

	*o = slice

	return nil
}

// LettersCancellationSubtestExists checks if the LettersCancellationSubtest row exists.
func LettersCancellationSubtestExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `letters_cancellation_subtests` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dbmodels: unable to check if letters_cancellation_subtests exists")
	}

	return exists, nil
}

// Exists checks if the LettersCancellationSubtest row exists.
func (o *LettersCancellationSubtest) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return LettersCancellationSubtestExists(ctx, exec, o.ID)
}
